% \section{Middleware for IoT}
% \subsection{Context}
% Le cours de Middleware for IoT a été donné par le professeur Thierry Monteil. Les objectifs principaux de ce cours sont de découvrir différentes approches et protocoles de communication, et de comprendre les enjeux de la communication entre objets connectés afin d'être capable de mettre en place des solutions adaptées au besoin.\\
% Ce cours, comme pour le cours de \hyperref[sec:service_architecture]{Service Architecture} donné par Ms. Nawal Guermouche, était sous la forme d'un MOOC (Massive Open Online Course), à la suite duquel nous avons eu une serie de travaux pratiques. Ces TP qui visent a illustrer les concepts abordés dans le MOOC, notamment l'utilisation d'MQTT, oneM2M et de Node-RED.\\
% L'objectif des TP était de comprendre comment faire intéragir plusieurs objets connectés entre eux, en choisisant les protocoles adaptés, tout en prenant en compte la diversité des infrastructures matérielles et logicielles exixtantes.

% \subsection{Technical Summary}
% Comme dit précédemment, durant ce cours nous avons abordés plusieurs protocoles de communication, et notamment Message Queuing Telemetry Transport (MQTT). Il s'agit d'un protocole de messagerie léger, conçu pour les appareils ayant des ressources limitées. Son fonctionnement est basé sur un broker, un serveur, qui gère des sujets de publication (des topics). Les clients "publishers" publient des messages sur des topics, et les clients "subscribers" recoivent des messages en s'abonnant à des topics.\\
% Grace à son architecture simple, le protocole MQTT est très utilisé dans l'IoT, où la consommation de bande passante doit être minimisée, et la fiabilité y être essentielle.\\

% Le second protocole que nous avons étudié est oneM2M. Il s'agit plus précisemment d'une norme soutenue par plusieurs organismes de standardisation, qui vise à fournir et assurer l'intéropérabilité des architectures IoT. Basée sur REST, oneM2M propose une structure hiérarchique permettant de modéliser des ressources pour une application IoT. Les ressources sont organisées en trois niveaux : les Application Entities (AE), les Containers (CNT) et les Content Instances (CI). Ce sont ces niveaux définissent l'espace de stockage hiérarchique des Servers. Les Application Entities (AE) représentent les fonctionnalités disponibles dans lesquelles il y a des containers (CNT) qui sont des catégories de données et des Content Instance (CI) qui sont des instances de données publiée.\\
% Ainsi, c'est au travers d'un container dans une AE, qu'un appareil IoT peut publier ou lire des informations.\\

% \subsection{Practical Work}
% Le premier projet des séances de TP, a été le déploiemment d'un broker MQTT, avec le logiciel Mosquitto, et la mise en place d'échanges de messages simple entre plusieurs ESP8266. Un ESP8266 jouant le role du bouton, le publisher, et un autre controllant une LED, le subscriber. Chaque changement de l'état du bouton était reflété sur l'extinction ou l'allumage de la LED.\\

% Le deuxième projet, qui était sensiblement le même que le premier mais avec oneM2M, a commencé par le suivit d'un tuto sous un Jupyter Notebook, pour en comprendre les concepts. Les premiers exercices de ce notebook nous ont permis de comprendre comment créer des AE, des containers, et des content instances. Puis, nous sommes allé plus loin en découvrant les créations de groupes, les notifications et les règles qui permettenht de mettre a jour les ressources de manière automatique.\\
% Ce n'est qu'une fois ces concepts  maîtrisés que nous avons utilisé un serveur oneM2M et un script Python pour simuler la même application qu'avec MQTT. Afin d'avoir quelque chose d'équivalent au premier projet, mon binome et moi avons simulé un “bouton” et une “LED” virtuelle. Un script Python nous permettait de créer des AE, des containers, et des content instances pour le bouton et la LED, et de gérer les notifications. 

% Si nous avions eu plus de temps sur ce projet, j'aurais aimé pouvoir intégrer Node-RED pour pouvoir manager plus facilement les flux de données entre les différents appareils IoT. Node-RED nous aurait apporté une interface visuelle, connectant les dispositifs matériels, les API et des services en ligne de manière intuitive.

% \subsection{Skills Acquired}
% \begin{table}[H]
%     \centering
%     \begin{tabular}{|p{3.5cm}|p{8cm}|p{3.5cm}|}
%     \hline
%     \textbf{Skill} & \textbf{Description} & \textbf{Level of Mastery} \\
%     \hline
%     Situate IoT Standards & Know how to situate the main standards for the Internet of Things & Advanced \\
%     \hline
%     Deploy IoT Architecture & Deploy an architecture compliant to an IoT standard and implement a sensor network & Intermediate \\
%     \hline
%     Configure OM2M & Deploy and configure an IoT architecture using OM2M & Intermediate \\
%     \hline
%     Interact with REST & Interact with the different resources of the architecture using REST services & Advanced \\
%     \hline
%     Integrate New Technology & Integrate a new technology into the deployed architecture & Intermediate \\
%     \hline
%     \end{tabular}
%     \caption{Skills Acquired}
%     \label{tab:skills_acquired}
% \end{table}


% \subsection{Analysis and remarks}

% La découverte et l'expérimentation de deux protocoles IoT complémentaires, MQTT (léger, adapté à des cas d'usage rapide et peu gourmands en ressources) et oneM2M (plus structuré et standardisé, offrant un cadre complet pour des applications IoT à grande échelle), m'ont permis de mieux saisir l'importance de l'interopérabilité dans l'Internet des Objets. La mise en pratique a été particulièrement instructive, de la configuration d'un broker Mosquitto, à la conception d'un mini-projet sur des ESP8266 et l'exploration de oneM2M au travers de scripts Python, en passant par Node-RED pour la mise en flux des données.
% Toutefois, j'aurais aimé approfondir davantage l'intégration directe de oneM2M dans Node-RED pour mieux en exploiter tout le potentiel, notamment en termes de notifications et de règles de gestion.

% Par ailleurs, l'installation des outils sur les machines personnelles nous a freinés, mon binome et moi, notamment sur la partie tuto oneM2M sur le notebook Jupyter. J'aurai aimé qu'une solution fonctionnelle, telle qu'une machine virtuelle à déployer, nous soit fourni en début de TP comme cela est fait notamment dans les TP du \hyperref[sec:service_architecture]{Service Architecture}.

% Sur le plan personnel, cette matière vient enrichir mon parcours en me donnant une vue plus globale des différentes approches de communication dans l'IoT. Les compétences acquises me seront utiles pour de futurs projets où il faudra choisir la solution la plus adaptée à un contexte précis.

% Souhaitant m'orienter vers le Master Spécialisé en TLS-Sec à l'issue de mon diplôme INSA, je regrette que la dimension sécurité de ces protocoles n'aient pas été abordé durant les travaux pratiques, car la sécurisation des échanges (chiffrement, authentification, protection contre les intrusions) constitue un enjeu majeur en IoT.

\section{Middleware for IoT}
\subsection{Context}
The Middleware for IoT course was taught by Professor Thierry Monteil. The main objectives of this course were to explore different approaches and communication protocols, and to understand the challenges of communication between connected devices in order to implement solutions tailored to specific needs.\\

Like the course \hyperref[sec:service_architecture]{Service Architecture} taught by Ms.\ Nawal Guermouche, this course was delivered in the form of a MOOC (Massive Open Online Course). Afterwards, we carried out a series of practical exercises designed to illustrate the concepts discussed in the MOOC, notably the use of MQTT, oneM2M, and Node-RED.\\

The goal of these practical sessions was to understand how multiple connected devices can interact with each other by choosing appropriate protocols, while taking into account the variety of existing hardware and software infrastructures.

\subsection{Technical Summary}
As mentioned earlier, we studied several communication protocols during this course, particularly Message Queuing Telemetry Transport (MQTT). This is a lightweight messaging protocol designed for devices with limited resources. Its functioning relies on a broker (a server) that manages publication topics. Client publishers publish messages on specific topics, and client subscribers receive messages by subscribing to these topics.\\

Thanks to its simple architecture, the MQTT protocol is widely used in IoT, where bandwidth consumption must be minimized and reliability is essential.\\

The second protocol we studied is oneM2M. More precisely, it is a standard endorsed by multiple standardization bodies, aiming to provide and ensure interoperability among IoT architectures. Based on REST, oneM2M proposes a hierarchical structure to model resources for an IoT application. The resources are organized on three levels: Application Entities (AE), Containers (CNT), and Content Instances (CI). These levels define the hierarchical storage space on servers. Application Entities (AE) represent available functionalities, within which there are Containers (CNT) that serve as data categories and Content Instances (CI) that hold published data instances.\\

Thus, it is through a container in an AE that an IoT device can publish or read information.

\subsection{Practical Work}
The first project in the practical sessions involved deploying an MQTT broker using Mosquitto and setting up simple message exchanges among several ESP8266 devices. One ESP8266 acted as a button (the publisher), while another controlled an LED (the subscriber). Any change in the button’s state was reflected by turning the LED on or off.\\

The second project, which was essentially the same as the first but with oneM2M, began with following a tutorial in a Jupyter Notebook to understand the core concepts. The first exercises in the notebook enabled us to learn how to create AEs, containers, and content instances. We then went a step further by exploring group creation, notifications, and rules that can automatically update resources.\\

Only after mastering these concepts did we use a oneM2M server and a Python script to simulate the same application we had built with MQTT. To achieve an equivalent setup to the first project, my partner and I simulated a virtual “button” and a virtual “LED.” A Python script allowed us to create AEs, containers, and content instances for both the button and the LED, as well as manage notifications. 

Had we had more time for this project, I would have liked to integrate Node-RED to more easily manage data flows among the various IoT devices. Node-RED would have provided a visual interface to intuitively connect hardware devices, APIs, and online services.

\subsection{Skills Acquired}
\begin{table}[H]
    \centering
    \begin{tabular}{|p{3.5cm}|p{8cm}|p{3.5cm}|}
    \hline
    \textbf{Skill} & \textbf{Description} & \textbf{Level of Mastery} \\
    \hline
    Situate IoT Standards & Know how to position the main standards for the Internet of Things & Advanced \\
    \hline
    Deploy IoT Architecture & Deploy an architecture compliant with an IoT standard and implement a sensor network & Intermediate \\
    \hline
    Configure OM2M & Deploy and configure an IoT architecture using OM2M & Intermediate \\
    \hline
    Interact with REST & Interact with different resources of the architecture using REST services & Advanced \\
    \hline
    Integrate New Technology & Integrate a new technology into the deployed architecture & Intermediate \\
    \hline
    \end{tabular}
    \caption{Skills Acquired}
    \label{tab:skills_acquired}
\end{table}

\subsection{Analysis and Remarks}
Discovering and experimenting with two complementary IoT protocols—MQTT (lightweight, suitable for quick use cases with minimal resource consumption) and oneM2M (more structured and standardized, offering a comprehensive framework for large-scale IoT applications)—has helped me understand the importance of interoperability in the Internet of Things. The practical work was especially instructive, from configuring a Mosquitto broker and designing a mini-project on ESP8266 devices, to exploring oneM2M via Python scripts and using Node-RED for data flow management.

However, I would have liked to delve deeper into the direct integration of oneM2M into Node-RED to fully leverage its potential, particularly in terms of notifications and management rules.

In addition, installing the necessary tools on our personal machines slowed down my partner and me, especially for the oneM2M tutorial in the Jupyter Notebook. I would have appreciated having a ready-to-use solution—such as a virtual machine—to deploy at the start of the practical sessions, similar to what was provided for the \hyperref[sec:service_architecture]{Service Architecture} TP sessions.

From a personal standpoint, this course enhanced my academic path by giving me a more comprehensive view of different communication approaches in IoT. The skills I acquired will be valuable for future projects that require choosing the most appropriate solution for a specific context.

Intending to pursue the Master’s Program in TLS-Sec after completing my INSA degree, I regret that the security aspects of these protocols were not addressed during the practical work. Ensuring secure exchanges (encryption, authentication, intrusion protection) is a major challenge in IoT.
